# 二叉堆 binary heap
## 结构性质
为一颗**完全二叉树（complete binary tree）** - 一颗被填满的二叉树（只允许底子不被填满），底层上的元素从左到右填入。  
高为h的完全二叉树有2^h到2^(h+1)个节点。  
**完全二叉树可以被储存在数组中，不需要指针。**  
对于在数组中编号为i的节点，**其父节点在数组中的编号为 [i/2]，其左子节点为i*2,右子节点为i*2+1**  
方便起见，从数组的1号元素开始储存。
## 堆序性质
对于每一个节点X，X的父节点小于（或等于）X中的关键字，根节点除外。
所以，最小元素总可以在根节点处找到。
## 基本操作
### 插入Insert
将元素X，插入下一个空闲位置，然后执行 **上滤percolate up**操作,维持堆序性质。

### 删除最小元素DeleteMin
用最后一个节点覆盖根节点，再对根节点执行**下滤percolate down**操作，以维持堆序性。

### 删除某个元素
强行使这个节点上移到根节点，再使用DeleteMin操作将其删除。

### 构建堆---把N个关键字作为输入放入**空**堆中  
对除最后一层的元素外，从下到上，对每个节点执行下滤操作。


## 补充：
* 找出二叉堆中小于某个值X的所有节点：执行先序遍历
* 只使用logN + loglogN + O(1) 次元素间的比较的DeleteMin：从根处的空穴开始，**沿着最小的子节点找到一条到叶节点的路径**，这需要logN次比较。为了将堆中最后一个元素放入空穴，再在这logN个元素中执行**二分查找（loglogN）**以安放这个元素。


## 推广- d-堆
所以节点都有d个子节点的"二叉堆"(二叉堆是特殊的d堆)
* Insert 变为 O(log d N)
* DeleteMin 在d较大时费事多，虽然树变浅了，但为了找出最小的子节点，（如果使标准算法）将花费d-1次比较，操作将提升为O(d log d N)
* 仍可用数组储存，只是将“2”换成d
* Insert操作比DeleteMin多时，可以提升性能
* 节点i的父节点： ⌊(i + d - 2)/d⌋ 
* 节点i的子节点：(i - 1)d + 2, ... , id+1