## Insertion sort 插入排序 O(N²)
* 平均的插入时间也是O(N²)
    * N个互异数的数组的**平均逆序数**为N(N-1)/4.(考虑两个相反的序列。)
* 插入排序在对小的或非常接近已经排序好的输入数据上。

## Shellsort 希尔排序
* 使用希尔增量:最坏情况Θ(N²)。 使用Hibbard增量：最坏情况Θ(N^(3/2))
* 或称**缩小增量排序（diminishing increment sort）**
* 选择一个序列h1,h2,h3,...,ht(递增的)，作为**增量序列(increment sequence)。** 
* 希尔增量序列: N/2, N/4, N/8,...,1 (倒) 
* Hibbard增量：1，3，7，...，2^k-1（关键在于相邻的增量之间没用公因子）
* **Sedgewick增量：该序列中的项或者是9\*4^i - 9\*2^i + 1,或者是4^i - 3\*2^i + 1。最坏情况时间为O(N^(4/3))。**
* 进行t次hk-排序：对于hk,hk+1,...,N-1中的每一个位置i，把其上的元素放到i,i-hk,i-2hk,...中的正确位置上。

## Heapsort 堆排序 O(N logN)
* 为避免使用第二个数组：每次DeleteMin之后，堆缩小1，作为堆的数组的最后一个单元就可以用来存放刚刚删除的元素（实际编写中，交换根元素与堆最后的元素即可）。（为得到降序可以用(max)堆）。

## Mergesort 归并排序 O(N logN)
* 最坏情形O(N logN)
* 需要拷贝操作，不便于用于主存排序
* 大多数外部排序的基础
* 可用于求**逆序对**的数目
  * **逆序对的数目 等于 使该序列有序所需要交换相邻两项的次数**

## Quicksort 快速排序 O(N logN)
* 平均运行时间O(N logN)
* **实践中最快的已知排序算法**
* Quicksort(S)过程：
    * 基准：如果S中只有一个元素或没有元素，则返回。
    * 取S中任一元素v，称之为**枢纽元(pivot)**。
    * 将S-{v}(S中除去v外的其余元素)分成两部分:S1 = {x∈S-{v} | **x ≤ v**} 和 S2 = {x∈S - {v} | **x ≥ v**}.
    * 返回结果{Quicksort(S1), v ,Quicksort(S2)} (需递归的执行)
* 枢纽元选取策略-三数中值分割法(Median-of-Three Partitioning): 选择左端、右端、中心(N/2)三个元素的中值作为枢纽元。消除了预排序输入的坏情形，并减少了越5%的运行时间。
* 分割策略：
    * 将枢纽元与最后的元素交换，使得枢纽元离开要被分割的数据段
    * 让i指向第一个元素，j指向低倒数第二个元素
    * 将i右移，已过小于枢纽元的元素，直到遇到**大于等于**枢纽元的元素。j则向左移，...
    * i，j都停止时交换两个元素
    * 反复交换直到i，j交错
    * 最后再将i指向的元素与最后的枢纽元交换
* 对于很小的数组(N≤20)，快速排序不如插入排序。

## 桶式排序 Bucket Sort
* 输入的元素中的最大元素≤M，输入N个元素->O(M + N)

## 排序的一般下界
* Ω(N logN)是极限
* 任何基于比较的排序算法在**最坏情况**下需要Ω(N logN)次比较(从而Ω(N logN)的时间)
    * 只要用到比较的任何排序算法在最坏情况下都需要 **⌈log(N!)⌉**次比较并平均需要log(N!)次比较
    * log(N!) = logN + log(N-1) + ...... + log2 + log1 = Ω(N logN)
* 使用决策树（decison tree）证明
* 任何基于比较的排序算法都需要平均Ω(N logN)次比较 (P197 Q7.39)

## 外部排序 External Sorting
将不能全部装入内存的数据，在海量存储器中排序。由于海量存储器不能随机访问，普通算法效率低。
* K路合并:每次读M个数据进内存进行排序需要的O(log_k (N/M) )
* 替换选择(replacement selection): 产生一个顺串的算法，应用优先队列。

## 其他：
* 如果一切具有相等关键字的元素都保持它们在输入数据时呈现的顺序，则这种排序算法就是稳定的(stable).
    * 稳定的
        * 冒泡排序
        * 插入排序
        * 归并排序
        * 桶式排序
        * 基数排序
    * 不稳定：
        * 希尔排序
        * 快速排序
        * 堆排序
    * 要是排序算法变成稳定的，可以附加第二个关键字来指示原顺序

## 总结
排序|最坏时间|最好时间|平均时间|空间|是否稳定
----|-------|-------|-------|----|-------
冒泡排序|O(n^2)|O(n^2)|O(n^2)|O(1)|是
插入排序|O(n^2)|O(n)|O(n^2)|O(1)|是
希尔排序|      |    |      |O(1)|否
选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|否
归并排序|O(nlogn)|O(nlogn)|O(nlogn)|O(n)|**是**
快速排序|O(n^2)|O(nlogn)|O(nlogn)|O(1)|**否**
堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|**否**
基数排序|O(kn)|O(kn)|O(kn)|O(n)|O(k+n)|是
* k: 数字位数